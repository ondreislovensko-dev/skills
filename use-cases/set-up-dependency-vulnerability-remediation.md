---
title: "Set Up Automated Dependency Vulnerability Remediation with AI"
slug: set-up-dependency-vulnerability-remediation
description: "Automatically detect, prioritize, and fix dependency vulnerabilities with AI-generated patches and upgrade paths."
skills: [coding-agent, security-audit, github]
category: development
tags: [security, dependencies, vulnerabilities, remediation, automation]
---

# Set Up Automated Dependency Vulnerability Remediation with AI

## The Problem

A 20-person SaaS startup has 340 npm dependencies across three services. Dependabot opens PRs, but nobody has time to review them — there are 47 open security PRs right now, some months old. The team cannot tell which vulnerabilities are actually exploitable in their context versus theoretical risks. A recent penetration test flagged two critical CVEs that had open Dependabot PRs sitting unreviewed for 11 weeks. Updating one major dependency broke the build last time someone tried, so now everyone is afraid to merge security updates.

## The Solution

Use the **security-audit** skill to assess which vulnerabilities are actually exploitable in your codebase, the **coding-agent** to generate safe upgrade paths with necessary code changes, and the **github** skill to manage PRs and coordinate the remediation workflow.

```bash
npx terminal-skills install security-audit coding-agent github
```

## Step-by-Step Walkthrough

### 1. Triage existing vulnerabilities

Start with your current backlog:

```
Run a security audit on our three services in ./api, ./web, and ./worker. For each vulnerability, determine: severity, whether the vulnerable code path is actually reachable in our codebase, and the upgrade path (is it a patch bump or a major version change?).
```

### 2. The agent produces a prioritized list

```
Vulnerability Triage — 3 services, 340 dependencies:

CRITICAL (exploitable, fix immediately):
- CVE-2024-4367 — pdf.js RCE, used in ./worker/pdf-parser.js (direct call)
- CVE-2024-29041 — express path traversal, reachable via file upload route

HIGH (exploitable, fix this sprint):
- CVE-2024-37890 — ws DoS, WebSocket server in ./api/realtime.js
- CVE-2024-28863 — tar arbitrary file write, used in backup restore flow

MEDIUM (not directly exploitable but upgrade is safe):
- 12 vulnerabilities — all patch-level bumps, no breaking changes

LOW (theoretical, no reachable code path):
- 31 vulnerabilities — vulnerable code exists in dependency but your app never calls it
```

### 3. Generate safe upgrade patches

```
For the 2 critical and 2 high vulnerabilities, generate upgrade patches. For each, show what version to upgrade to, any breaking API changes, and the code modifications needed in our codebase to stay compatible.
```

### 4. The agent produces ready-to-merge patches

For each vulnerability, the agent creates a branch with the dependency bump and any necessary code changes:

```
Patch 1: CVE-2024-4367 (pdf.js RCE)
- Upgrade: pdfjs-dist 3.4.120 → 4.2.67 (major version)
- Breaking changes: getDocument() API changed, render method signature updated
- Files modified: worker/pdf-parser.js (2 API call updates), worker/pdf-renderer.js (1 change)
- New tests added: worker/__tests__/pdf-parser.test.js (3 test cases for new API)
- Branch: fix/cve-2024-4367-pdfjs

Patch 2: CVE-2024-29041 (express path traversal)
- Upgrade: express 4.18.2 → 4.21.0 (minor version)
- Breaking changes: none
- Files modified: package.json, package-lock.json
- Existing tests pass with no modifications
- Branch: fix/cve-2024-29041-express

Patch 3: CVE-2024-37890 (ws DoS)
- Upgrade: ws 8.13.0 → 8.17.1 (minor version)
- Breaking changes: none, but maxPayload default changed
- Files modified: api/realtime.js (explicit maxPayload set to preserve behavior)
- Branch: fix/cve-2024-37890-ws

Patch 4: CVE-2024-28863 (tar arbitrary file write)
- Upgrade: tar 6.1.15 → 6.2.1 (minor version)
- Breaking changes: none
- Branch: fix/cve-2024-28863-tar
```

### 5. Set up continuous remediation

```
Create a GitHub Actions workflow that runs weekly: scans for new vulnerabilities, filters out unreachable code paths, and auto-creates PRs for patch-level fixes. For major version bumps, create an issue with an impact analysis instead.
```

The agent generates a workflow that triages vulnerabilities by reachability, auto-merges safe patches, and flags risky upgrades for human review.

## Real-World Example

Priya, a senior developer at a 20-person SaaS startup, inherits a backlog of 47 unreviewed Dependabot PRs after a penetration test flags two critical CVEs.

1. Priya asks the agent to triage all vulnerabilities across three services — it identifies 4 actually exploitable issues out of 47
2. The agent generates patches for the 4 exploitable vulnerabilities, including a pdf.js major version upgrade that requires changing two API calls in the worker service
3. Priya reviews and merges the 4 critical patches in one afternoon instead of wading through all 47 PRs
4. The 12 medium-severity patch bumps are auto-merged after CI passes — no code changes needed
5. The remaining 31 low-priority alerts are documented and deprioritized with justification, clearing the backlog. The weekly automation catches new vulnerabilities before they pile up again

## Tips for Sustainable Remediation

- **Triage by reachability first** — a critical CVE in code you never call is lower priority than a moderate CVE in your hot path
- **Batch minor updates weekly** — do not let patch-level bumps accumulate into a mountain of 47 PRs
- **Pin major versions explicitly** — auto-merge patches, but always review major version bumps with a human
- **Track mean-time-to-remediate** — measure how long critical CVEs stay open and set a team SLA (e.g., 48 hours for critical)

## Related Skills

- [test-generator](../skills/test-generator/) -- Generate tests to verify dependency upgrades do not break functionality
- [cicd-pipeline](../skills/cicd-pipeline/) -- Integrate vulnerability scanning into CI/CD workflows
